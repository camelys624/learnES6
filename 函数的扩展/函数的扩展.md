# 函数的扩展

## 1. 函数参数的默认值

###  基本用法

ES6之前，不能直接为函数的参数指定默认值，只能采用变通的办法。

```js
function log(x, y) {
  y = y || 'world';
  console.log(x, y)
}

log('hello')  // hello, world
log('hello', 'china') // hello china
log('hello', '') // hello world
```

上面代码检查函数`log`的参数`y`有没有赋值，如果没有，则指定默认值为`world`。这种写法的缺点在于，如果参数`y`赋值了，但是对应的布尔值为`false`，则该赋值不起作用。就上上面的代码的最后一行，参数`y`等于空字符串，结果被改为默认值。

为了避免这个问题，通常需要先判断一下参数`y`是否被赋值，如果没有，再等于默认值。

```js
if (typeof y === 'undefined') {
  y = 'world'
}
```

ES6允许为函数的参数设置默认值。

```js
function log(x, y = 'world') {
  console.log(x, y)
}

log('hello')  // hello, world
log('hello', 'china') // hello china
log('hello', '')  // hello
```

可以看到，ES6的写法比ES5简洁许多，而且非常自然。下面是另一个例子。

```js
function Point(x = 0, y = 0) {
  this.x = x;
  this.y = y;
}

const p = new Piont();
p // {x: 0, y: 0}
```

除了简洁，ES6的写法还有两个好处；首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使将来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。

参数变量是默认声明的，所以不能用`let`或`const`再次声明。

使用参数默认值时，函数不能有同名参数。

```js
// 不报错
function foo (x, x, y) {
  // do something
}

// 报错
function foo (x, x, y = 0) {
  // do something
}
// SyntaxError: Duplicate parameter name not allowed in this context
```

另外，一个容易忽略的地方是，参数默认值不是传值的，而是每次都会重新计算默认表达式的值，也就是说，参数默认值是惰性求值的。

```js
let x = 99;
function foo(p = x + 1) {
  console.log(p);
}

foo() // 100
x = 100
foo() // 101
```

上面代码中，参数`p`的默认值是`x + 1`。时每次调用函数`foo`，都会重新计算`x+1`，而不是默认`p`等于100.

### 与解构赋值默认值结合使用

参数默认值可以与解构赋值的默认值，结合起来使用。

```js
function foo)({x, y = 5}) {
  console.log(x, y);
}

foo({}) // undefined 5
foo({x: 1}) // 1 5
f({x: 1, y: 2}) //  1 2
f() // TypeError: Cannot read property 'x' of undefined
```

上面代码指定，如果没有提供参数，函数`foo`的参数默认为一个空对象。

下面是另一个解构赋值默认值的例子。

```js
function foo({x, y = 5} = {}) {
  console.log(x, y);
}

foo() // undefined 5
```

上面代码指定，如果没有提供参数，函数`foo`的参数默认为一个空对象。

下面是另一个解构赋值默认值的例子。

```js
fuction fetch(url, {body = '', method = 'GET', headers = {}} = {}) {
  console.log(method);
}

fetch('http://excample.com', {})
// 'GET'
```

```js
// 下面两个函数的区别
function m1({x = 0, y = 0} = {}) {
  return [x, y];
}

function m2({x, y} = {x = 0, y = 0}) {
  return [x, y];
}
```

上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。

```js
// 函数没有参数的情况
m1()  // [0,0]
m2()  // [0,0]

// x和y都有值的情况
m1({x: 3, y: 8}) // [3, 8]
m2({x: 3, y: 8}) // [3, 8]

// x 有值，y 无值的情况
m1({x: 3}) // [3, 0]
m2({x: 3}) // [3, undefined]

// x 和 y 都无值的情况
m1({}) // [0, 0];
m2({}) // [undefined, undefined]

m1({z: 3}) // [0, 0]
m2({z: 3}) // [undefined, undefined]
```

### 参数默认值的位置

通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。

```js
// 例一
function f(x = 1, y) {
  return [x, y];
}

f() // [1, undefined]
f(2)  // [2, undefined]
f(, 1)  // 报错
f(undefined, 1) // [1, 1]

// 例二
function f(x, y = 5, z) {
  return [x, y, z];
}

f() // [undefined, 5, undefined]
f(1)  // [1, 5, undefined]
f(1, 2) // 报错
f(1, undefined, 2)  // [1, 5, 2]
```

上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入`undefined`。

如果传入`undefined`，将出发该参数等于默认值，`null`则没有这个效果。

```js
function foo(x = 5, y = 6) {
  console.log(x, y)
}

foo(undefined, null)
// 5 null
```

上面代码中，`x`参数对应`undefined`，如果触发了默认值，`y`参数等于`null`，就没有触发默认值。

-----------

### 函数的 length 属性

指定了默认值以后，函数的`length`属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，`length`属性将失真。

```js
(function (a) {}).length  // 1_
(function (a = 5) {}).length  // 0
(function (a, b, c = 5) {}).length  // 2
```

上面代码中，`length`属性的返回值，等于函数的参数个数减去指定默认值的参数个数。比如，上面最后一个函数，定义了3个参数，其中有一个参数`c`指定了默认值，因此`length`属性等于`3`减去`1`，最后得到`2`.

这是因为`length`属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的 rest 参数也不会计入`length`属性。

```js
(function (...args) {}).length  // 0
```

如果设置了默认值的参数不是尾参数，那么`length`属性也不再计入后面的参数了。

```js
(function (a = 0, b, c) {}).length  // 0
(function (a, b = 1, c) {}).length  // 1
```

### 作用域

一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域(context)。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。

```js
var x = 1;

function f(x, y = x) {
  console.log(y)
}

f(2)  // 2
```

上面代码中，参数`y`的默认值等于变量`x`。调用函数`f`时，参数形成一个单独的作用域。在这个作用域里面，默认值变量`x`指向等一个参数`x`，而不是全局变量`x`，所以输出是`2`.

再看下面的例子。

```js
let x = 1;

function f(y = x) {
  let x = 2;
  console.log(y);
}

f() // 1
```

上面代码中，函数`f`调用时，参数`y = x`形成一个单独的作用域。这个作用域里面，变量`x`本身没有定义，所以指向外层的全局变量`x`。函数调用时，函数体内部的局部变量`x`影响不到默认值变量`x`.

如果此时，全局变量`x`不存在，就会报错。

```js
function f(y = x) {
  let x = 2;
  console.log(y)
}

f()   // ReferenceError: x is not defined
```

下面这样写，也会报错。

```js
var x = 1;
function foo (x = x) {
  //  ...
}

foo() // ReferenceError: x is not defined
```

上面代码中，参数`x = x`形成一个单独作用域。实际执行的是`let x =x`,由于暂时性死区的原因，这行代码会报错“x未定义”。

如果参数的默认值是一个函数，该函数的作用域也遵循这个规则。

```js
let foo = 'outer';

function bar(func = () => foo) {
  let foo = 'inner';
  console.log(func());
}

bar();  // outer
```

上面代码中，函数`bar`的参数`func`的默认值是一个匿名函数，返回值为变量`foo`。函数参数形成的单独作用域里面，并没有定义变量`foo`，所以`foo`指向外层的全局变量`foo`，因此输出`outer`。

如果写成下面这样，就会报错。

```js
function bar(func = () => foo) {
  let foo = 'inner';
  console.log(func());
}

bar();  // ReferenceError: foo is not defined
```

上面代码中，匿名函数里面的`foo`指向函数外层，但是函数外层并没有声明变量`foo`，所以就报错了。

下面是一个更复杂的例子。

```js
var x = 1;
function foo(x, y = function() {x = 2;}) {
  var x = 3;
  y();
  console.log(x);
}

foo() // 3
x //1
```

上面代码中，函数`foo`的参数形成一个单独作用域。这个作用域里面首先声明了变量`x`，然后声明了变量`y`，`y`的默认值是一个匿名函数。这个匿名函数内部的变量`x`，指向同一个作用域的第一个参数`x`。函数`foo`内部又声明了一个内部变量`x`，该变量与第一个变量`x`由于不是统一个作用域，所以不是同一个变量，因此执行`y`后，内部变量`x`和外部全局变量`x`的值都没变。

如果将`var x = 3`的`var`去除，函数`foo`的内部变量`x`就指向第一个参数`x`，与匿名函数内部的`x`是一致的，所以最后输出的就是2，而外层的全局变量`x`依然不受影响.

```js
var x = 1;
function foo(x, y = function() {x = 2;}) {
  x = 3;
  y();
  console.log(x);
}

foo() // 3
x //1
```

### 应用

利用参数默认值,可以指定某一个参数不得省略,如果省略就抛出一个错误.

```js
funtion throwIfMissing() {
  throw new Error('Missing parameter');
}

function foo(mustBeProvided = throwIfMissing()) {
  return mustBeProvided;
}

foo()
// Error: Missing parameter
```

上面代码的`foo`函数,如果调用的时候没有参数,就会调用默认值`throwIfMissing`函数,从而抛出一个错误.

从上面代码还可以看出,参数`mustBeProvided`的默认值等于`throwIfMissing`函数的运行结果,这表明参数的默认值不是定义时执行,而是在运行时执行.如果参数已经赋值,默认值中的函数就不会运行.

另外,可以讲参数默认值设为`undefined`,表明这个参数是可以省略的.

```js
function foo(option1 = undefined) {
  //... do something
}
```

## 2. rest 参数

ES6引入了rest参数(形式为`...变量名`),用于获取函数的多余参数,这样就不需要使用`arguments`对象了.rest参数搭配的变量是一个数组,该变量将多余的参数放入数组中.

```js
function add(..values) {
  let sum = 0;

  for (var val of values) {
    sum += val;
  }

  return sum;
}

add(2, 5, 3)  // 10
```

上面代码的`add`函数是一个求和函数,利用rest参数,可以向该函数传入任意数目的参数.

下面是一个rest参数代替`arguments`变量的例子.

```js
// arguments变量的写法
function sortNumber() {
  return Array.prototype.silce.call(arguments).sort();
}

// rest参宿的写法
const sortNumbers = (...numbers) => numbers.sort();
```

上面代码的两种写法,比较后可以发现,rest参数的写法更自然也更简洁.

`arguments`对象不是数组,而是一个类似数组的对象.所以为了使用数组的方法,必须使用`Array.prototype.slice.call`先将其转为数组.rest参数就不存在这个问题,它就是一个真正的数组,数组特有的方法都可以使用.下面是一个利用rest参数改写数组`push`方法的例子.

```js
function push(array, ...items) {
  items.forEach(function(item) {
    array.push(item);
    console.log(item);
  });
}

var a = [];
push(a, 1, 2, 3)
```

注意,rest参数之后不能再有其他参数(即只能是最后一个参数),否则会报错.

```js
// 报错
function f(a, ...b, c) {
  // do something
}
```

函数的`length`属性,不包括rest参数

```js
(function (a) {}).length  // 1
(function (...a) {}).length // 0
(function (a, ...b) {}).length  // 1
```

## 3. 严格模式

从ES5开始,函数内部可以设定为严格模式.

```js
function doSomething(a, b) {
  'use strict'
  // code
}
```

ES2016作了一点修改,规定只要函数参数使用了默认值,解构赋值,或者扩展运算符,那么函数内部就能显式设定为严格模式,否则会报错.

```js
// 报错
function doSomething(a, b = a) {
  'use strict'
  // code
}

// 报错
const doSomething = function ({a, b}) {
  'use strict'
  // code
}

// 报错
const doSomething = (...a) => {
  'use strict';
  // code
}

const obj = {
  // 报错
  doSomething({a, b}) {
    'use strict';
    // code
  }
}
```

这样规定的原因是,函数内部的严格模式,同时适用于函数体和函数参数.但是,函数执行的时候,先执行函数参数,然后再执行函数体.这样就有一个不合理的地方,只有从函数体之中,才能知道参数是否应该以严格模式执行,但是参数却应该先于函数体执行.

```js
function doSomething(value = 070) {
  'use strict';
  return value;
}
```

上面代码中,参数`value`的默认值是八进制数`070`,但是严格模式下不能用前缀`0`表示八进制,所以应该报错.但是实际上,JavaScript引擎会成功执行`value = 070`,然后进入函数体内部,发现需要用严格模式执行,这是才回报错.

虽然可以先解析函数体代码,再执行参数代码,但是这样无疑就增加了复杂性.因此,标准索性禁止了这种用法,只要参数使用了默认值,解构赋值,或者扩展运算符,就不能显式指定严格模式.

两种方法可以规避这种限制.一种设定全局性的严格模式,这是合法的.

```js
'use strict';

function doSomething(a, b = a) {
  // code
}
```

第二种是把函数包在一个无参数的立即执行函数里面.

```js
const doSomething = (function () {
  'use strict';
  return function(value = 42) {
    return value;
  }
}());
```

## 4. name 属性

函数的 `name` 属性,返回该函数的函数名.

```js
function foo() {}
foo.name  // 'foo'
```

这个熟悉早就被浏览器广泛支持,但是直到ES6,才将其写入了标准.

需要注意的是,ES6对这个属性的行为做出了一些修改.如果讲一个匿名函数赋值给一个变量,ES5的`name`属性,会返回空字符串,而ES6的`name`属性会返回实际的函数名.

```js
var f = function () {}

// ES5
f.name  // ''

// ES6
f.name  // 'f'
```

上面代码中,变量`f`等于一个匿名函数,ES5和ES6的`name`属性返回的值不一样.

如果将一个具名函数赋值给一个变量,则ES5和ES6的`name`属性都返回这个具名函数原本的名字.

```js
const bar = function baz() {};

// ES5
bar.name  // 'baz'

// ES6
bar.name  // 'baz'
```

`Function`构造函数返回的函数实例,`name`属性的值为`anonymous`.

```js
(new Function).name // 'anonymous'
```

`bind`返回的函数,`name`属性值会加上`bound`前缀.

```js
function foo() {};
foo.bind({}).name // 'bound foo'

(function() {}).bind({}).name // 'bound '
```
