# 变量的解构赋值

## 1. 数组的解构赋值

### 基本用法

ES6 允许按照一定模式,从数组和对象中提取值,对变量进行赋值,这被称为解构 (Destructuring).

ES6 允许写成下面这样.

```js
let [a, b, c] = [1, 2, 3];
```

上面的代码表示,可以从数组中提取值,按照对应位置,对变量赋值.

本质上,这种写法属于"模式匹配",只要等好两边的模式相同,左边的变量就会被赋予对应的值.下面是一些使用嵌套数组进行解构的例子.

```js
let [foo, [bar], baz] = [1, [2], 3];
foo // 1
bar // 2
baz // 3

let [, , third] = ["foo", "bar", "baz"];
third // "baz"

let [x, , y] = [1, 2, 3];
x // 1
y // 3

let [head, ...tail] = [1, 2, 3, 4];
head  // 1
tail  // [2, 3, 4]

let [x, y, ...z] = ['a'];
x   // 'a'
y   // undefined
z   // []
```

如果解构不成功,变量的值就等于 `undefined`.

另一种情况就是不完全解构,即等号左边的模式,只匹配一部分的等号右边的数组.这种情况下,解构依然可以成功.

```js
let [x, y] = [1, 2, 3];

x  // 1
y  // 2

let [a, [b], d] = [1, [2, 3], 4];
a  // 1
b  // 2
c  // 4
```

如果等号的右边不是数组 (或者严格的说,不是可遍历的结构),那么将会报错.

```js
// 报错
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = {};
```

对于 Set 结构,也可以使用数组的解构赋值.

```js
let [x, y, z] = new Set(['a', 'b', 'c']);
x  // 'a'
```

### 默认值

解构赋值允许指定默认值.

```js
let [foo = true] = [];
foo  // true

let [x, y = 'b'] = ['a']  // x='a', y='b'
let [x, y = 'b'] = ['a', undefined] // x='a', y='b'
```

注意，ES6 内部使用严格相等运算符 (===)，判断一个位置是否有值。所以，只有当一个数组成员严格等于 `undefined`，默认值才会生效。

```js
let [x = 1] = [undefined];
x  // 1

let [x = 1] = [null];
x  // null
```

上面代码中，如果一个数组成员是 `null`，默认值就不会生效，因为`null`不严格等于`undefined`。如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。

```js
function f() {
  console.log('aaa');
}

let [x = f()] = [1];
```

上面代码中，因为`x`能取到值，所以函数`f`根本不会执行。上面的代码其实等价于下面的代码。

```js
let x;
if([1][0] === undefined) {
  x = f();
} else {
  x = [1][0]
}
```

默认值可以引用解构赋值的其他变量，但该变量必须已声明。

```js
let [x = 1, y = x] = [];  // x=1, y=1
let [x = 1, y = x] = [2];   // x=2, y=2
let [x = 1, y = x] = [1, 2];  // x=1, y=2
let [x = y, y = 1] = [];  // ReferenceError: y is not defined
```

## 2. 对象的解构赋值

### 简介

解构不仅可以用于数组，还可以用于对象。

```js
let { foo, bar } = { foo: 'aaa', bar: 'bbb' };
foo   // 'aaa'
bar   // 'bbb'
```

对象的解构与数组的有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定，而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。

```js
let { bar, foo } = { foo: 'aaa', bar: 'bbb' };
foo   // 'aaa'
bar   // 'bbb'

let { baz } = { foo: 'aaa', bar: 'bbb' };
baz // undefined
```

如果解构失败，变量的值会变为`undefined`。

对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。

```js
// 例一
let {log, sin, cos} = Math;

// 例二
const {log} = console
log('hello')  // hello
```

如果变量名与属性名不一致，必须写成下面这样。

```js
let {foo: baz} = {foo: 'aaa', bar: 'bbb'};
baz // 'aaa'

let obj = {first: 'hello', last: 'world'};
let {first: f, last: 1} = obj;
f // 'hello'
1 // 'world'
```

这实际上说明，对象的解构赋值是将下面的形式的简写（参见《对象的扩展》一章）。

```js
// {foo, bar}上面的代码其实等价于下面的代码{foo: foo, bar: bar}
let {foo: foo, bar: bar} = {foo: 'aaa', bar: 'bbb'};
```

也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋值给对应的变量。真正被赋值的是后者，而不是前者。

```js
let {foo: baz} = {foo: 'aaa', bar: 'bbb'};
baz // 'aaa'
foo // undefined
```

上面的代码中，`foo`是匹配的模式，`baz`才是变量。真正被赋值的是变量`baz`，而不是前者模式`foo`。

与数组一样，解构也可以用于嵌套结构的对象。

```js
let obj = {
  p: [
    'hello',
    {y: 'world'}
  ]
};

let {p: [x, { y }]} = obj;
x  // 'hello'
y  // 'world'
```

### 默认值

对象的解构也可以指定默认值。

```js
var {x = 3} = {};
x  // 3

var {x, y = 5} = {x: 3};
x  // 3
y  // 5

var {x: y = 3} = {x: 5};
y  // 5
```

默认值生效的条件是，对象的属性值严格等于`undefined`.

### 注意点

(1) 如果要将一个已经声明的变量用于解构赋值,必须非常小心.

```js
// 错误的写法
let x;
{x} = {x: 1};
// SyntaxError: syntax error
```

上面代码的写法会报错,因为 JavaScript 引擎会将`{x}`理解成一个代码块,从而发生语法错误.只有不将大括号写在行首,避免 JavaScript 将其解释为代码块,才能解决这个问题.

```js
// 正确的写法
let x;
({x} = {x: 1});
```
